<h1 id="usage"><a aria-hidden="true" class="anchor-heading" href="#usage"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Usage</h1>
<h2 id="query"><a aria-hidden="true" class="anchor-heading" href="#query"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Query</h2>
<p>(This is used in Kibana Dev Tools)</p>
<pre><code>GET /_cluster/health
    --------- ------
       API    command
GET /_cat/nodes?v
    ----  ----  --
                query parameter
</code></pre>
<p>API - begins with <code>_</code> by convention</p>
<h3 id="list-of-apis"><a aria-hidden="true" class="anchor-heading" href="#list-of-apis"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>List of APIs</h3>













<table><thead><tr><th align="center">api</th><th>meaning</th></tr></thead><tbody><tr><td align="center"><code>_cat</code></td><td>output data into human-readable format.<br> command: <code>indices</code>, <code>nodes</code></td></tr></tbody></table>
<h3 id="list-of-query-parameters"><a aria-hidden="true" class="anchor-heading" href="#list-of-query-parameters"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>List of query parameters</h3>













<table><thead><tr><th align="center">query param</th><th>meaning</th></tr></thead><tbody><tr><td align="center"><code>?v</code></td><td>verbose - show the descriptive header in the output</td></tr></tbody></table>
<h2 id="curl"><a aria-hidden="true" class="anchor-heading" href="#curl"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>cURL</h2>
<p>Copy from Kibana Dev Tool command</p>
<pre class="language-sh"><code class="language-sh">curl -XGET "https://localhost:9200/.kibana/_search" -H 'Content-Type: application/json' --cacert /e/elasticsearch/elasticsearch-8.0.1-windows-x86_64/elasticsearch-8.0.1/config/certs/http_ca.crt -u elastic:ww=86Lhxttvw8D_zEqr1 -d'
{
  "query": {
    "match_all": {}
  }
}'
</code></pre>
<ul>
<li>The <code>-X GET</code> to specify HTTP action/verb.</li>
<li><code>-H 'Content-Type: application/json'</code> Content-type header is required when having request body (which is in JSON format). Otherwise Elasticsearch will reject the request.</li>
<li>YAML or other formats are supported as well.</li>
</ul>
<h2 id="add-index"><a aria-hidden="true" class="anchor-heading" href="#add-index"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Add index</h2>
<p>E.g. add <code>pages</code> index to the database</p>
<pre><code>PUT /pages
</code></pre>
<ul>
<li><code>GET /_cluster/health</code> and <code>GET /_cat/indices'v</code> shows the newly added <code>pages</code> index has <span style="color:yellow"><em>yellow</em></span> health. Because the replica shard is <strong>unassigned</strong> as there is only 1 node.
<pre><code>health status index uuid                   pri rep docs.count docs.deleted store.size pri.store.size
yellow open   pages eyrfJpxxQIWBz7q5sucgrw   1   1          0            0       225b           225b
</code></pre>
</li>
</ul>
<p>To add index with specify shard and replica</p>
<pre><code>PUT /products
{
  "settings": {
    "number_of_shards": 2,
    "number_of_replicas": 2
  }
}
</code></pre>
<h2 id="adding-node"><a aria-hidden="true" class="anchor-heading" href="#adding-node"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Adding Node</h2>
<ol>
<li>Download another set of ES files in another directory</li>
<li>In the original ES directory, obtain the enrollment token
<pre class="language-sh"><code class="language-sh">bin\elasticsearch-create-enrollment-token.bat -s node
</code></pre>
</li>
<li>Modify the config/elasticsearch.yml for <code>cluster.name</code> and <code>node.name</code>. If it is running on another different machine, more config have to be changed</li>
<li>Start up ES with security enabled by passing the enrollment token obtained previously
<pre class="language-sh"><code class="language-sh">bin\elasticsearch.bat --enrollment-token &#x3C;enrollment-token>
</code></pre>
</li>
</ol>
<h2 id="adding-documents-data"><a aria-hidden="true" class="anchor-heading" href="#adding-documents-data"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Adding documents (data)</h2>
<p><code>POST, /&#x3C;index>/_doc</code> followed by the json object for the data.
(the <code>_doc</code>) means this is a document</p>
<pre><code>POST /products/_doc
{
  "name": "Coffee",
  "price": 34,
  "in_stock": 10
}
</code></pre>
<p>result:</p>
<pre><code>{
  "_index" : "products",
  "_id" : "42j-T38B_ZjsYwbHxq8s",
  "_version" : 1,
  "result" : "created",
  "_shards" : {
    "total" : 3,
    "successful" : 2,
    "failed" : 0
  },
  "_seq_no" : 0,
  "_primary_term" : 1
}
</code></pre>
<p><code>_shards</code> shows the status of the data stored in shards. -> <code>total</code>: primary + number of replica shards.</p>
<p>To specify <code>_id</code> of the document -> <code>PUT /&#x3C;index>/_doc/&#x3C;id></code></p>
<pre><code>PUT /products/_doc/23iD20x
{
  xxx (the json object)
}
</code></pre>
<h2 id="getting-document"><a aria-hidden="true" class="anchor-heading" href="#getting-document"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Getting document</h2>
<pre><code>GET /&#x3C;index>/_doc/&#x3C;id>
GET /products/_doc/100
</code></pre>
<p>The result shows the json object inside <code>_source</code></p>
<pre><code>{
  "_index" : "products",
  "_id" : "100",
  "_version" : 2,
  "_seq_no" : 2,
  "_primary_term" : 1,
  "found" : true,
  "_source" : {
    "name" : "Tissue",
    "price" : 3,
    "in_stock" : 4
  }
}
</code></pre>
<h2 id="update-document"><a aria-hidden="true" class="anchor-heading" href="#update-document"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Update document</h2>
<pre><code>POST /&#x3C;index>/_update/&#x3C;id>
</code></pre>
<pre><code>POST /products/_update/100
{
  "doc": {
    "in_stock": 3
  }
}
</code></pre>
<p>Update API -> <code>/&#x3C;index>/_update</code>
The document is immutable. The <code>Update</code> API is just replacing the existing document with modified document. It saves us effort for sending 2 requests <code>GET</code> and <code>PUT</code> which might incur network latency and overhead</p>
<h2 id="scripted-update"><a aria-hidden="true" class="anchor-heading" href="#scripted-update"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Scripted Update</h2>
<p>Without needing to know the existing data to update the data with script</p>
<pre><code>POST /&#x3C;index>/_update/&#x3C;id>
// script key, source key
// ctx = context
// _source = access _source field in the document
// .&#x3C;field> = the field inside _source
// --- single line script ---
POST /products/_update/100
{
  "script": {
    "source": "ctx._source.in_stock--"
  }
}
</code></pre>
<p>Use the script with function parameters</p>
<pre><code>POST /products/_update/100
{
  "script": {
    "source": "ctx._source.in_stock -= params.quantity",
    "params": {
      "quantity": 4
    }
  }
}
// --- multi-line script ---
POST /products/_update/100
{
  "script": {
    "source": """
      if (ctx._source.in_stock &#x3C;= 0) {
        ctx.op = 'noop';
      }
      ctx._source.in_stock--;
    """,
    "params": {
      "quantity": 4
    }
  }
}
</code></pre>
<p>the 'noop' = no-operation, means do nothing. If it does nothing, it will not show successful
<code>"_shards": {   "successful": 0 }</code></p>
<h2 id="upsert"><a aria-hidden="true" class="anchor-heading" href="#upsert"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a><code>Upsert</code></h2>
<p>Update or insert. If document exists, it updates, otherwise, it inserts.
It must have "<code>script</code>" or "<code>doc</code>" for update</p>
<pre><code>POST /products/_update/101
{
  "script": {
    "source": "ctx._source.in_stock++"
  },
  "upsert": {
    "name": "tv",
    "price": 2444,
    "in_stock": 5
  }
}
</code></pre>
<p>Can check the response "<code>result</code>" is <code>created</code> or <code>updated</code></p>
<pre><code>{
  "_index" : "products",
  "_id" : "101",
  "_version" : 3,
  "result" : "updated",
  "_shards" : {
    "total" : 3,
    "successful" : 1,
    "failed" : 0
  },
  "_seq_no" : 26,
  "_primary_term" : 2
}
</code></pre>
<h2 id="replace-documents"><a aria-hidden="true" class="anchor-heading" href="#replace-documents"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Replace documents</h2>
<p>It is actually the same as <a href="/mydocs/notes/g0g7i6q68tpcz27w22apuls#adding-documents-data">Adding document</a></p>
<p>Because the elasticsearch document is immutable, basically it is just removing and adding new document again.</p>
<h2 id="delete-documents"><a aria-hidden="true" class="anchor-heading" href="#delete-documents"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Delete documents</h2>
<pre><code>DELETE /&#x3C;index>/_doc/&#x3C;id>
DELETE /products/_doc/101
</code></pre>
<h2 id="update-by-query-update-data-with-matching-data"><a aria-hidden="true" class="anchor-heading" href="#update-by-query-update-data-with-matching-data"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Update by query (update data with matching data)</h2>
<p>with <code>script</code> for update operation and <code>query</code> for matching data operation</p>
<pre><code>POST /products/_update_by_query
{
  "script": {
    "source": "ctx._source.in_stock--"
  },
  "query": {
    "match_all": {}
  }
}
</code></pre>
<h2 id="delete-by-query-delete-data-with-matching-data"><a aria-hidden="true" class="anchor-heading" href="#delete-by-query-delete-data-with-matching-data"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Delete by query (delete data with matching data)</h2>
<p>delete data if it matches the query. Note it is using <code>POST</code></p>
<pre><code>POST /products/_delete_by_query
{
  "query": {
    "match_all": {}
  }
}
</code></pre>
<h2 id="batch-processing"><a aria-hidden="true" class="anchor-heading" href="#batch-processing"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Batch Processing</h2>
<p>Bulk API request. The header content-type has to be <code>Content-Type: application/x-ndjson</code>.
There are 4 actions: index (add or overwrite the document), create (add document if not exist), update, delete
The document has to be in one line for document or query.
And it has to be line separated!! And for the last line, it requires a empty new line
It is good for having script to generate the request for large amount of data manipulation</p>
<pre><code>POST /_bulk
{ "index": { "_index": "products", "_id": 200 }}
{ "name": "Reader", "price": 19, "in_stock": 39 }
{ "create": { "_index": "products", "_id": 201 }}
{ "name": "Bread", "price": 2, "in_stock": 100 }

// can use index in the api, thus no need to put the index in every line
POST /products/_bulk
{ "update": { "_id": 201 }}
{ "doc": { "price": 22}}
{ "delete": { "_id": 200}}
</code></pre>
<h3 id="using-curl"><a aria-hidden="true" class="anchor-heading" href="#using-curl"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Using cURL</h3>
<p>Make sure the Header content type is using <code>x-ndjson</code> and the file is read by <code>--data-binary</code> to preserve the last empty new line in the file.</p>
<pre><code>curl -XPOST -H 'Content-Type: application/x-ndjson' --cacert /e/elasticsearch/elasticsearch-8.0.1-windows-x86_64/elasticsearch-8.0.1/config/certs/http_ca.crt -u elastic:password https://localhost:9200/products/_bulk --data-binary "@products-bulk.json"
</code></pre>
<hr>
<strong>Backlinks</strong>
<ul>
<li><a href="/mydocs/notes/g0g7i6q68tpcz27w22apuls">Usage</a></li>
</ul>